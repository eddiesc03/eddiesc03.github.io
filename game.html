<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>JavaScript Block Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            transition: background-color 0.3s;
        }

        #game-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            border: 2px solid;
            transition: border-color 0.3s;
        }
        
        #theme-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            font-size: 28px;
            cursor: pointer;
            border: 2px solid;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
            z-index: 20;
        }
        
        #mobile-controls {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: none;
            justify-content: space-around;
            align-items: center;
            user-select: none;
            z-index: 10;
        }
        
        @media (max-width: 768px), (pointer: coarse) {
            #mobile-controls {
                display: flex;
            }
        }
        
        .controls-dpad { display: grid; grid-template-areas: ". up ." "left down right"; gap: 15px; }
        .control-btn {
            width: 70px; height: 70px; background-color: rgba(128, 128, 128, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 15px;
            display: flex; justify-content: center; align-items: center;
            font-size: 40px; color: white; cursor: pointer;
        }
        .control-btn.rotate { width: 80px; height: 80px; border-radius: 50%; font-size: 45px; }
        .control-btn:active { background-color: rgba(200, 200, 200, 0.7); }
        #btn-left { grid-area: left; }
        #btn-right { grid-area: right; }
        #btn-down { grid-area: down; }

        /* Intro Overlay Styles */
        #intro-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        #intro-overlay h1 { font-size: 2.5em; margin-bottom: 20px; }
        #intro-overlay p { font-size: 1.2em; max-width: 500px; line-height: 1.6; }
        #intro-overlay strong { color: #4CAF50; }
        #start-game-btn {
            margin-top: 30px;
            padding: 15px 30px;
            font-size: 1.5em;
            cursor: pointer;
            border-radius: 10px;
            border: 2px solid white;
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        #start-game-btn:hover { background-color: #45a049; }

    </style>
</head>
<body>
    <div id="game-container">
        <div id="intro-overlay">
            <h1>Block Game</h1>
            <p><strong>Desktop Controls:</strong><br>Use <strong>Arrow Keys</strong> to move and <strong>Up Arrow</strong> to rotate.</p>
            <p><strong>Mobile Controls:</strong><br>Use the on-screen <strong>buttons</strong> to move and rotate the pieces.</p>
            <button id="start-game-btn">Start Game</button>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="theme-toggle">üåô</div>
        <div id="mobile-controls">
            <div class="controls-dpad">
                <div class="control-btn" id="btn-left">‚Üê</div>
                <div class="control-btn" id="btn-right">‚Üí</div>
                <div class="control-btn" id="btn-down">‚Üì</div>
            </div>
            <div class="control-btn rotate" id="btn-rotate">‚Üª</div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const themeToggleButton = document.getElementById('theme-toggle');
        const introOverlay = document.getElementById('intro-overlay');
        const startGameButton = document.getElementById('start-game-btn');
        const rotateButton = document.getElementById('btn-rotate');
        
        // --- Game State & Sizing ---
        let cellSize, currentShape, nextShape, f, c2, score, isGameOver, isGameStarted = false;

        // --- THEME MANAGEMENT ---
        const lightTheme = { /* ... unchanged ... */
            bg: '#FFF', bodyBg: '#EEE', grid: '#EEE', border: '#000', sidebarBg: '#000', sidebarText: '#0F0',
            gameOverBg: 'rgba(0, 0, 0, 0.75)', gameOverText: '#FFF', toggleBg: '#FFF', toggleText: '#000',
        };
        const darkTheme = { /* ... unchanged ... */
            bg: '#1a1a1a', bodyBg: '#121212', grid: '#444', border: '#FFF', sidebarBg: '#000', sidebarText: '#0F0',
            gameOverBg: 'rgba(255, 255, 255, 0.75)', gameOverText: '#000', toggleBg: '#333', toggleText: '#FFF',
        };
        let isDarkMode = false;
        let currentTheme = lightTheme;

        // --- SHAPE DATA --- (Comprehensive list)
        const shapesData = [ /* ... unchanged from previous version ... */
            { c: 'rgb(100, 100, 100)', t: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { c: 'rgb(180, 180, 180)', t: [0, 0, 0, 1, 0, 0, 0, 0, 0, 0] },
            { c: 'rgb(139, 69, 19)', t: [0, -1, 0, 0, 0, 1, 0, 0, 0, 0] }, { c: 'rgb(160, 82, 45)', t: [0, 0, 0, 1, 1, 1, 0, 0, 0, 0] },
            { c: 'rgb(0, 255, 255)', t: [0, -1, 0, 0, 0, 1, 0, 2, 0, 0] }, { c: 'rgb(238, 201, 0)', t: [0, 0, 1, 0, 0, 1, 1, 1, 0, 0] },
            { c: 'rgb(128, 0, 128)', t: [0, 0, -1, 0, 1, 0, 0, 1, 0, 0] }, { c: 'rgb(0, 0, 255)', t: [0, -1, 0, 0, 0, 1, -1, 1, 0, 0] },
            { c: 'rgb(255, 165, 0)', t: [0, -1, 0, 0, 0, 1, 1, 1, 0, 0] }, { c: 'rgb(0, 255, 0)', t: [0, 0, 1, 0, -1, 1, 0, 1, 0, 0] },
            { c: 'rgb(255, 0, 0)', t: [0, 0, -1, 0, 1, 1, 0, 1, 0, 0] }, { c: 'rgb(255, 0, 255)', t: [0, 0, -1, 0, 1, 0, 0, -1, 0, 1] },
            { c: 'rgb(0, 128, 0)', t: [0, -2, 0, -1, 0, 0, 0, 1, 0, 2] }, { c: 'rgb(255, 105, 180)', t: [0, 0, 1, 0, 0, -1, 0, 1, -1, 1] },
            { c: 'rgb(255, 20, 147)', t: [0, 0, -1, 0, 0, -1, 0, 1, 1, 1] }, { c: 'rgb(75, 0, 130)', t: [0, -1, 0, 0, 0, 1, 1, 1, 1, 0] },
            { c: 'rgb(148, 0, 211)', t: [0, -1, 0, 0, 0, 1, -1, 1, -1, 0] }, { c: 'rgb(255, 127, 80)', t: [0, 0, 0, 1, 1, 1, -1, 0, -1, -1] },
            { c: 'rgb(255, 99, 71)', t: [0, 0, 0, -1, -1, -1, 1, 0, 1, 1] }, { c: 'rgb(60, 179, 113)', t: [0, 0, 1, 0, 0, 1, 1, 1, 0, -1] },
            { c: 'rgb(46, 139, 87)', t: [0, 0, -1, 0, 0, 1, -1, 1, 0, -1] }, { c: 'rgb(218, 165, 32)', t: [-1, 0, 0, 0, 1, 0, 0, -1, 0, 1] },
            { c: 'rgb(0, 191, 255)', t: [-1, 0, 1, 0, -1, 1, 0, 1, 1, 1] }, { c: 'rgb(255, 215, 0)', t: [0, 0, -1, 0, -1, 1, 1, 0, 1, -1] },
            { c: 'rgb(106, 90, 205)', t: [-1, 0, 0, 0, 0, 1, 1, 1, 1, 2] }, { c: 'rgb(255, 69, 0)', t: [0, -1, 0, 0, 0, 1, 0, 2, 1, 0] },
            { c: 'rgb(255, 140, 0)', t: [0, -1, 0, 0, 0, 1, 0, 2, -1, 0] }, { c: 'rgb(34, 139, 34)', t: [-1, -1, 0, -1, 0, 0, 0, 1, 1, 1] },
            { c: 'rgb(50, 205, 50)', t: [1, -1, 0, -1, 0, 0, 0, 1, -1, 1] }
        ];

        class Shape { /* ... class content unchanged ... */
            constructor() { this.x = Array(5).fill(0); this.y = Array(5).fill(0); this.y2 = 0; this.ypos = 0; this.xpos = 4; this.c = 'black'; }
            reset() {
                const q = Math.floor(Math.random() * shapesData.length);
                const shapeInfo = shapesData[q]; this.c = shapeInfo.c; const t = shapeInfo.t;
                for (let i = 0; i < 5; i++) { this.x[i] = t[i * 2]; this.y[i] = t[i * 2 + 1]; }
                this.y2 = 0; this.xpos = 4;
            }
            move() {
                this.y2 += 0.03 * cellSize; this.ypos = Math.floor(this.y2 / cellSize);
                ctx.fillStyle = this.c;
                for (let i = 0; i < 5; i++) { ctx.fillRect((this.x[i] + this.xpos) * cellSize, (this.y[i] * cellSize) + this.y2, cellSize, cellSize); }
                for (let j = 0; j < 5; j++) {
                    const gridX = this.x[j] + this.xpos; const gridY = this.y[j] + this.ypos + 1;
                    if (gridX < 0 || gridX >= 10 || gridY >= 14 || (gridY >= 0 && f[gridX][gridY] === 1)) { this.placeShape(); return; }
                }
            }
            placeShape() {
                for (let i = 0; i < 5; i++) {
                    const gridX = this.x[i] + this.xpos; const gridY = this.y[i] + this.ypos;
                    if (gridY < 1) { isGameOver = true; return; }
                    if(gridY >= 0 && gridY < 14 && gridX >= 0 && gridX < 10){ f[gridX][gridY] = 1; c2[gridX][gridY] = this.c; }
                }
                score += 10; this.x = [...nextShape.x]; this.y = [...nextShape.y]; this.c = nextShape.c;
                nextShape.reset(); this.y2 = 0; this.xpos = 4;
            }
            drawNextShape() {
                ctx.fillStyle = this.c;
                for (let i = 0; i < 5; i++) { ctx.fillRect((this.x[i] + 11.5) * cellSize, (this.y[i] + 5) * cellSize, cellSize, cellSize); }
            }
            rotate() {
                for (let i = 0; i < 5; i++) { const currentX = this.x[i]; this.x[i] = Math.round(-this.y[i]); this.y[i] = Math.round(currentX); }
            }
            handleKeyPress(event) {
                if (isGameOver && event.key === 'r') { resetGame(); return; }
                if (isGameOver) return;
                if (this.ypos >= 13) return;
                if (event.key === 'ArrowUp') {
                    const tempX = [...this.x], tempY = [...this.y]; let canRotate = true;
                    for (let i = 0; i < 5; i++) {
                        const newX = -tempY[i] + this.xpos, newY = tempX[i] + this.ypos;
                        if (newX < 0 || newX >= 10 || newY >= 13 || (newY >= 0 && f[Math.round(newX)][Math.round(newY)] === 1)) { canRotate = false; break; }
                    }
                    if (canRotate) this.rotate();
                }
                if (event.key === 'ArrowDown') {
                    let canMove = true;
                    for(let i=0; i<5; i++){
                        const gridX = this.x[i] + this.xpos, gridY = this.y[i] + this.ypos + 1;
                        if(gridY >= 14 || (gridY >= 0 && f[gridX][gridY] === 1)){ canMove = false; break; }
                    }
                    if (canMove) this.y2 += cellSize;
                }
                if (event.key === 'ArrowRight') {
                     let canMove = true;
                     for(let i=0; i<5; i++){
                        const gridX = this.x[i] + this.xpos + 1, gridY = this.y[i] + this.ypos;
                        if(gridX >= 10 || (gridY >= 0 && f[gridX][gridY] === 1)){ canMove = false; break; }
                    }
                    if(canMove) this.xpos++;
                }
                if (event.key === 'ArrowLeft') {
                    let canMove = true;
                     for(let i=0; i<5; i++){
                        const gridX = this.x[i] + this.xpos - 1, gridY = this.y[i] + this.ypos;
                        if(gridX < 0 || (gridY >= 0 && f[gridX][gridY] === 1)){ canMove = false; break; }
                    }
                    if(canMove) this.xpos--;
                }
            }
        }

        function toggleTheme() { /* ... unchanged ... */
            isDarkMode = !isDarkMode; currentTheme = isDarkMode ? darkTheme : lightTheme;
            document.body.style.backgroundColor = currentTheme.bodyBg; canvas.style.borderColor = currentTheme.border;
            themeToggleButton.style.backgroundColor = currentTheme.toggleBg; themeToggleButton.style.color = currentTheme.toggleText;
            themeToggleButton.style.borderColor = currentTheme.border; themeToggleButton.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåô';
        }

        function resetGame() {
            score = 0; isGameOver = false; rotateButton.textContent = '‚Üª';
            f = Array(10).fill(0).map(() => Array(14).fill(0));
            c2 = Array(10).fill(0).map(() => Array(14).fill(null));
            for (let i = 0; i < 10; i++) { f[i][13] = 1; }
            currentShape = new Shape(); nextShape = new Shape();
            currentShape.reset(); nextShape.reset();
        }
        
        function resizeCanvas() { /* ... unchanged ... */
            const widthToHeight = 14 / 13; let newWidth = window.innerWidth; let newHeight = window.innerHeight;
            let newWidthToHeight = newWidth / newHeight;
            if (newWidthToHeight > widthToHeight) { newWidth = newHeight * widthToHeight; } else { newHeight = newWidth / widthToHeight; }
            canvas.width = newWidth; canvas.height = newHeight;
            cellSize = canvas.height / 13;
        }

        function drawGameOverScreen() {
            ctx.fillStyle = currentTheme.gameOverBg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = currentTheme.gameOverText;
            ctx.font = `${cellSize * 1.5}px Arial`;
            ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - cellSize);
            ctx.font = `${cellSize * 0.7}px Arial`;
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + cellSize * 0.5);
            
            // DYNAMIC RESTART TEXT
            const isMobile = window.innerWidth <= 768 || navigator.maxTouchPoints > 0;
            const restartText = isMobile ? "Tap ‚ü≥ to Restart" : "Press 'r' to Restart";
            
            ctx.font = `${cellSize * 0.6}px Arial`;
            ctx.fillText(restartText, canvas.width / 2, canvas.height / 2 + cellSize * 1.5);
        }

        function drawGame() {
            ctx.fillStyle = currentTheme.bg; ctx.fillRect(0, 0, canvas.width, canvas.height);
            const sidebarX = 10 * cellSize; const sidebarWidth = 4 * cellSize;
            ctx.fillStyle = currentTheme.sidebarBg; ctx.fillRect(sidebarX, 0, sidebarWidth, canvas.height);
            ctx.fillStyle = currentTheme.sidebarText; ctx.font = `${cellSize}px Arial`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const textX = sidebarX + sidebarWidth / 2;
            ctx.fillText("Next", textX, cellSize * 1); ctx.fillText("Shape", textX, cellSize * 2);
            ctx.fillText("Score", textX, cellSize * 11); ctx.fillText(score, textX, cellSize * 12);
            
            if (!isGameOver) {
                nextShape.drawNextShape(); currentShape.move();
            } else {
                // If game is over, keep drawing next shape for context
                nextShape.drawNextShape();
            }

            for (let j = 0; j < 13; j++) {
                let blocksInRow = 0;
                for (let i = 0; i < 10; i++) {
                    if (f[i][j] === 1) {
                        blocksInRow++;
                        ctx.fillStyle = c2[i][j] || 'gray';
                        ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
                if (blocksInRow === 10) {
                    score += 100;
                    for (let l = j; l > 0; l--) {
                        for (let k = 0; k < 10; k++) { f[k][l] = f[k][l - 1]; c2[k][l] = c2[k][l - 1]; }
                    }
                    for (let k = 0; k < 10; k++) { f[k][0] = 0; c2[k][0] = null; }
                }
            }
            
            ctx.strokeStyle = currentTheme.grid; ctx.lineWidth = 1;
            for (let i = 1; i < 10; i++) {
                ctx.beginPath(); ctx.moveTo(i * cellSize, 0); ctx.lineTo(i * cellSize, 13 * cellSize); ctx.stroke();
            }
            for (let j = 1; j < 13; j++) {
                ctx.beginPath(); ctx.moveTo(0, j * cellSize); ctx.lineTo(10 * cellSize, j * cellSize); ctx.stroke();
            }

            if (isGameOver) {
                rotateButton.textContent = '‚ü≥'; // Change icon to restart symbol
                drawGameOverScreen();
            }
        }
        
        function gameLoop() {
            if (isGameStarted) {
                drawGame();
            }
            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        function simulateKeyPress(key) { currentShape.handleKeyPress({ key: key }); }
        
        window.addEventListener('keydown', (e) => currentShape.handleKeyPress(e));
        window.addEventListener('resize', resizeCanvas);
        themeToggleButton.addEventListener('click', toggleTheme);

        startGameButton.addEventListener('click', () => {
            introOverlay.style.display = 'none';
            isGameStarted = true;
            resetGame(); // Ensure game is fresh on first start
        });

        // Mobile control listeners
        document.getElementById('btn-left').addEventListener('touchstart', (e) => { e.preventDefault(); simulateKeyPress('ArrowLeft'); });
        document.getElementById('btn-right').addEventListener('touchstart', (e) => { e.preventDefault(); simulateKeyPress('ArrowRight'); });
        document.getElementById('btn-down').addEventListener('touchstart', (e) => { e.preventDefault(); simulateKeyPress('ArrowDown'); });
        rotateButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (isGameOver) {
                resetGame();
            } else {
                simulateKeyPress('ArrowUp');
            }
        });

        // --- Initial Setup ---
        resizeCanvas();
        toggleTheme(); toggleTheme(); // Set to light theme by default
        gameLoop();

    </script>
</body>
</html>